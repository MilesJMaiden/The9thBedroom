<!--
  File: blog-post-saime-warehouse-simulation.html

  Notes:
  - Uses the same template structure as your previous blog post pages (navbar, alternating bands, post-container).
  - Image filenames come from your LaTeX (update paths if needed).
  - Replace anchor-only navbar links with index.html#... if your site routing requires it.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>SAIME: AI-Driven Warehouse Simulation in Unity</title>
  <meta
    name="description"
    content="SAIME: a modern, modular Unity architecture for scalable AI-driven warehouse simulation—ECS + object pooling, JSON-driven initialization, ML-Agents RL, VR via XR Interaction Toolkit, and Whisper voice commands."
  />

  <style>
    .skip-link {
      position: absolute;
      left: -999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
      background: #000;
      color: #fff;
      padding: 8px;
      z-index: 1000;
    }
    .skip-link:focus { position: static; width: auto; height: auto; }

    header, .navbar { background-color: #666; color: #fff; }

    body.blog-post-page main#main > section:nth-of-type(odd)  { background-color: #e0e0e0; }
    body.blog-post-page main#main > section:nth-of-type(even) { background-color: #f5f5f5; }

    body.blog-post-page main#main > section {
      padding: var(--space-5) 0;
      border-top: 1px solid #ccc;
      border-bottom: 1px solid #ccc;
      scroll-margin-top: calc(var(--nav-h) + var(--space-2));
    }

    body.blog-post-page main#main > section:first-of-type {
      padding-top: calc(var(--space-5) + var(--nav-h));
    }

    pre { overflow-x: auto; }
    pre code { white-space: pre; }

    .meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    .meta-tile {
      background: rgba(255,255,255,0.6);
      border: 1px solid #ccc;
      border-radius: 12px;
      padding: 12px 14px;
    }
    .meta-tile .k { font-size: 0.85rem; opacity: 0.85; margin: 0; }
    .meta-tile .v { font-weight: 700; margin: 6px 0 0; }

    .post-figure { margin-top: 18px; }
    .post-figure img { width: 100%; height: auto; border-radius: 12px; border: 1px solid #ccc; }
    .post-figure .cap { font-size: 0.9rem; opacity: 0.9; margin-top: 8px; }

    .callout {
      border: 1px solid #ccc;
      border-radius: 12px;
      background: rgba(255,255,255,0.7);
      padding: 14px 16px;
      margin-top: 16px;
    }
    .callout h3 { margin-top: 0; }
  </style>

  <link rel="preload" href="../styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="styles.css"></noscript>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap"
    rel="stylesheet"
    crossorigin="anonymous"
  >

  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    crossorigin="anonymous"
  >
</head>

<body class="blog-post-page">
  <a href="#main" class="skip-link">Skip to content</a>

  <!-- =========================================================
       HEADER / NAVBAR (TEMPLATE-MATCH)
       ========================================================= -->
  <header>
    <nav class="navbar" role="navigation">
      <a href="index.html" class="brand-logo" aria-label="9TH BEDROOM home">
        <img src="../images/logo.svg" alt="9th Bedroom logo" class="logo-icon">
        <span class="logo-text">9TH BEDROOM</span>
      </a>

      <div class="navbar-links">
        <a href="#home">Home</a>
        <a href="#about">About</a>
        <a href="#projects">Projects</a>
        <a href="#gallery">Portfolio</a>
        <a href="#blog" class="active">Blog</a>
        <a href="cv.html">Contact</a>
      </div>

      <button
        class="hamburger"
        type="button"
        aria-label="Toggle menu"
        aria-expanded="false"
        aria-controls="navbar-menu"
      >
        <svg width="24" height="24" viewBox="0 0 24 24" aria-hidden="true">
          <rect y="2"  width="24" height="2" rx="1"/>
          <rect y="11" width="24" height="2" rx="1"/>
          <rect y="20" width="24" height="2" rx="1"/>
        </svg>
      </button>

      <div id="navbar-menu" class="navbar-menu" role="menu" aria-hidden="true">
        <a role="menuitem" href="#home">Home</a>
        <a role="menuitem" href="#about">About</a>
        <a role="menuitem" href="#projects">Projects</a>
        <a role="menuitem" href="#gallery">Portfolio</a>
        <a role="menuitem" href="#blog">Blog</a>
        <a role="menuitem" href="cv.html">Contact</a>
        <button class="close-menu-btn" type="button" aria-label="Close menu">&times;</button>
      </div>
    </nav>
  </header>

  <!-- =========================================================
       BLOG POST PAGE
       ========================================================= -->
  <main id="main">

    <!-- HERO -->
    <section class="blog-post-hero post-section" id="top">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card">
            <p class="post-kicker">Unity • Simulation • ECS • RL • VR • Voice</p>

            <h1 class="post-title">
              SAIME: <em>AI-Driven Warehouse Simulation</em>
              <span style="display:block; font-size:0.7em; font-weight:400; opacity:0.9;">
                Modern architecture for scalable, interactive, and intelligent systems
              </span>
            </h1>

            <p class="post-subtitle">
              This post summarizes SAIME: an AI-driven warehouse simulation built in Unity that models robots navigating a grid environment to optimize
              delivery tasks and obstacle avoidance. The project evolves a functional legacy prototype into a modern, modular architecture designed for
              scalability, maintainability, and interactivity—introducing object pooling, ScriptableObjects, JSON-driven initialization, Unity ECS,
              reinforcement learning with Unity ML-Agents, VR using XR Interaction Toolkit, and voice commands via the OpenAI Whisper API.
            </p>

            <div class="post-actions">
              <a class="btn" href="blog.html">Back to Blog</a>
              <a class="btn" href="cv.html">Contact</a>
            </div>

            <div class="meta-grid">
              <div class="meta-tile">
                <p class="k">Author</p>
                <p class="v">Joshua J. Davies</p>
              </div>
              <div class="meta-tile">
                <p class="k">Engine</p>
                <p class="v">Unity (ECS + Object Pooling)</p>
              </div>
              <div class="meta-tile">
                <p class="k">AI stack</p>
                <p class="v">RL / MARL via Unity ML-Agents</p>
              </div>
              <div class="meta-tile">
                <p class="k">Interaction</p>
                <p class="v">Desktop + VR + Voice</p>
              </div>
            </div>

            <div class="callout">
              <h3 style="margin-bottom:8px;">What changed vs. the legacy version?</h3>
              <ul style="margin:0; padding-left: 18px;">
                <li>Monolithic initialization → modular + data-driven setup (JSON + ScriptableObjects).</li>
                <li>Manual instantiation loops → reusable Object Pools.</li>
                <li>Loosely synced state → event-driven synchronization + better debugging.</li>
                <li>GameObject-centric world → scalable ECS entities + multithreaded systems.</li>
                <li>Keyboard/mouse only → VR parity + voice control via Whisper.</li>
              </ul>
            </div>

            <div class="post-toc" aria-label="Table of contents">
              <div class="filter-container">
                <a class="filter-btn" href="#abstract">ABSTRACT</a>
                <a class="filter-btn" href="#introduction">INTRODUCTION</a>
                <a class="filter-btn" href="#legacy">LEGACY ANALYSIS</a>
                <a class="filter-btn" href="#transition">MODERN ARCHITECTURE</a>
                <a class="filter-btn" href="#ecs">ECS &amp; POOLING</a>
                <a class="filter-btn" href="#json">JSON INITIALIZATION</a>
                <a class="filter-btn" href="#simulation">SIMULATION ENHANCEMENTS</a>
                <a class="filter-btn" href="#rl">REINFORCEMENT LEARNING</a>
                <a class="filter-btn" href="#vr">VR &amp; CAMERA</a>
                <a class="filter-btn" href="#voice">VOICE (WHISPER)</a>
                <a class="filter-btn" href="#debug">DEBUGGING</a>
                <a class="filter-btn" href="#conclusion">CONCLUSION</a>
              </div>
            </div>

          </article>
        </div>
      </div>
    </section>

    <!-- ABSTRACT -->
    <section id="abstract" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Abstract</h2>
            <p>
              This report outlines the development of an AI-driven warehouse simulation built in Unity, modelling robots navigating a grid-based
              environment to optimize object delivery and obstacle avoidance. The system transitioned from a legacy implementation—limited by manual
              instantiation, hardcoded logic, and low extensibility—into a modernized, modular architecture designed for scalability and interactivity.
              The redesign integrates object pooling, ScriptableObjects, JSON-driven initialization, Unity ECS, reinforcement learning via
              :contentReference[oaicite:0]{index=0}, multi-agent extensions, an event-driven communication layer,
              a debugging suite, VR support with :contentReference[oaicite:1]{index=1}, and voice commands using the
              :contentReference[oaicite:2]{index=2} API.
            </p>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- INTRODUCTION -->
    <section id="introduction" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Introduction</h2>
            <p>
              The project began as a Unity simulation prototype modelling agents interacting with a discrete grid environment. While the initial (legacy)
              code demonstrated core mechanics—navigation, object placement, and basic rendering—it relied on manual instantiation, tightly coupled logic,
              and inflexible configuration. Over three months, the codebase was modernized with a focus on modular architecture, reusability, runtime
              performance, and data-driven environment setup via JSON.
            </p>
            <p>
              The modern system is designed to support real-world simulation and research workflows: scalable environments, configurable agent counts,
              hybrid ECS/GameObject visualization, interactive tools, and multiple input modalities (desktop, VR, voice).
            </p>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- LEGACY ANALYSIS -->
    <section id="legacy" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Legacy Code Analysis</h2>

            <h3>Core components</h3>
            <ul>
              <li><code>WorldRendererBox</code>: environment initialization + scene rendering (tiles, agents, boxes, tables).</li>
              <li><code>DeliveryAgentBox</code>: agent wrapper exposing ML-Agents action requests.</li>
              <li><code>WorldBoxScriptableObject</code>: world state, grid map, agent actions, basic events.</li>
              <li><code>Square</code>: per-cell state (obstacle/goal/agent/object metadata).</li>
            </ul>

            <h3>Environment initialization (legacy)</h3>
            <pre><code>void Start() {
    string[] lines = asset.text.Split('\n');
    string[] init_data = lines[0].Trim().Split(' ');

    n_agents = int.Parse(init_data[2]);
    height = int.Parse(init_data[0]);
    width = int.Parse(init_data[1]);

    World.Initialize(height, width, n_agents);

    // Creating tiles
    for (int z = 0; z &lt; height; z++) {
        for (int x = 0; x &lt; width; x++) {
            GameObject tile = Instantiate(tilePrefab, new Vector3(x, 0, height - z - 1), Quaternion.identity);

            if (line[x] == 'g') {
                World.map[height - z - 1, x].is_goal = true;
                tile.GetComponent&lt;MeshRenderer&gt;().material = goalMaterial;
            }
        }
    }

    // Instantiate agents
    for (int i = 0; i &lt; n_agents; i++) {
        InstantiateAgent();
    }

    requestDecisions();
}</code></pre>

            <h3>Legacy issues → modernization targets</h3>
            <ul>
              <li><strong>Manual instantiation overhead:</strong> nested loops created significant runtime and GC pressure → <strong>Object Pooling</strong>.</li>
              <li><strong>Hardcoded map coupling:</strong> map layout bound to scripts → <strong>JSON-driven configuration</strong>.</li>
              <li><strong>Monolithic setup:</strong> difficult extension/debug → <strong>modular environment pipeline</strong> + ScriptableObjects.</li>
              <li><strong>Loose state sync:</strong> grid state vs. scene could diverge → <strong>event-driven synchronization</strong>.</li>
            </ul>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- TRANSITION -->
    <section id="transition" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Transition to a Modernized Architecture</h2>

            <p>
              The modernization replaces tightly coupled logic with modular subsystems and data-driven initialization. Key Unity features include
              ScriptableObjects for reusable configs, Object Pooling for low-GC runtime, and ECS for high-entity-count scalability. Communication shifts
              to event-driven patterns so that simulation, UI, debugging overlays, and hybrid visualization remain consistent.
            </p>

            <div class="post-figure">
              <img
                src="UMLCodebaseArchitecture.png"
                alt="UML class diagram of the modernized architecture"
                loading="lazy"
              />
              <div class="cap">UML class diagram of the modernized architecture (UMLCodebaseArchitecture.png).</div>
            </div>

            <h3>Key components</h3>
            <ul>
              <li><code>WorldManager</code>: orchestration—init, simulation state, global coordination.</li>
              <li><code>AgentManager</code>: agent lifecycle—pooling, initialization, resets.</li>
              <li><code>JsonLoader</code>: parse JSON → structured environment data.</li>
              <li><code>DeliveryAgent</code>: agent behavior container—RL actions + heuristic fallback.</li>
              <li><code>ObjectPool</code>: reusable entities (tiles/shelves/agents) to minimize instantiation.</li>
              <li><code>TileComponent</code>: ECS tile metadata (walkability, occupancy, height).</li>
              <li><code>EventSystem</code>: broadcast simulation events (movement, goal completion, resets).</li>
              <li><code>UIController</code>: desktop + VR UI parity.</li>
            </ul>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- ECS & POOLING -->
    <section id="ecs" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">ECS Integration and Object Pooling</h2>

            <p>
              ECS replaces GameObject-centric environment management with data-oriented entities and multithreaded systems. Prefabs are stored in a
              Subscene and converted via baking into ECS entities. Pools then reuse instantiated entities to reduce allocations during resets and dynamic
              environment changes.
            </p>

            <h3>Tile baking example</h3>
            <pre><code>public class TileBaker : Baker&lt;TileAuthoring&gt; {
    public override void Bake(TileAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);

        AddComponent(entity, new TileComponent {
            IsWalkable = authoring.IsWalkable,
            Height = authoring.Height
        });
    }
}</code></pre>

            <h3>Object pool (ECS entities)</h3>
            <pre><code>public class ObjectPool {
    private Queue&lt;Entity&gt; pool = new Queue&lt;Entity&gt;();
    private Entity prefab;

    public ObjectPool(Entity prefab, int initialSize, EntityManager entityManager) {
        this.prefab = prefab;
        for (int i = 0; i &lt; initialSize; i++) {
            var entity = entityManager.Instantiate(prefab);
            pool.Enqueue(entity);
        }
    }

    public Entity GetEntity(EntityManager entityManager) {
        if (pool.Count &gt; 0) return pool.Dequeue();
        return entityManager.Instantiate(prefab);
    }

    public void ReturnEntity(Entity entity) {
        pool.Enqueue(entity);
    }
}</code></pre>

            <div class="callout">
              <h3>Observed impact</h3>
              <ul style="margin:0; padding-left:18px;">
                <li>Lower CPU overhead during initialization and resets (less instantiate/destroy churn).</li>
                <li>Faster simulation updates via ECS multithreading (better scaling with entity count).</li>
                <li>Cleaner separation of data (components) and logic (systems), improving maintainability.</li>
              </ul>
            </div>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- JSON -->
    <section id="json" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">JSON-Driven Initialization</h2>

            <p>
              JSON-driven initialization replaces hardcoded map layouts and enables runtime environment customization without recompilation. JSON defines
              dimensions and object placement (e.g., shelves), and can be extended with rotation, scaling, agent metadata, and model variants.
            </p>

            <h3>Parsing and initialization snippet</h3>
            <pre><code>EnvironmentData environmentData = _jsonLoader.LoadLatestEnvironmentData();

_worldData = new WorldData(
    environmentData.dimensions.length,
    environmentData.dimensions.width,
    environmentData.numberOfAgents
);

foreach (var obj in environmentData.objects) {
    if (obj.type.Equals("Shelf", StringComparison.OrdinalIgnoreCase)) {
        Vector3 position = new Vector3(
            float.Parse(obj.properties.location.x),
            0,
            float.Parse(obj.properties.location.y)
        );

        GameObject shelf = _shelfPool.GetObject();
        shelf.transform.position = position;
        shelf.name = $"Shelf_{obj.objectId}";
    }
}</code></pre>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- SIMULATION ENHANCEMENTS -->
    <section id="simulation" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Simulation Enhancements</h2>

            <h3>Agent initialization via AgentManager</h3>
            <pre><code>public void InitializeAgents(int numberOfAgents, WorldData worldData, ObjectPool agentPool,
                             List&lt;GameObject&gt; shelvesList, Material carriedMaterial, Material uncarriedMaterial) {
    ResetAgents();
    for (int i = 0; i &lt; numberOfAgents; i++) {
        Vector3 spawnPosition = FindRandomValidPosition(worldData.Width, worldData.Height, worldData);
        GameObject agentObj = agentPool.GetObject();
        agentObj.name = $"Agent_{i}";
        agentObj.transform.position = spawnPosition;

        DeliveryAgent deliveryAgent = agentObj.GetComponent&lt;DeliveryAgent&gt;();
        deliveryAgent.Initialize(i, spawnPosition, 0, false, shelvesList, worldData,
                                 carriedMaterial, uncarriedMaterial, maxSteps: 1000);
        _agents.Add(agentObj);
    }
}</code></pre>

            <h3>Event-driven communication</h3>
            <p>
              A centralized event layer broadcasts world changes (movement, goal completion, resets) to UI, visualization, and debugging systems, keeping
              ECS state and scene representation synchronized.
            </p>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- RL -->
    <section id="rl" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Reinforcement Learning with Unity ML-Agents</h2>

            <p>
              Agents are trained using reinforcement learning to optimize delivery and navigation tasks. Observations include the agent’s position,
              facing direction, carrying state, and local grid metadata within an observation window. A heuristic fallback enables manual or scripted
              control for debugging and development parity when trained policies are unavailable.
            </p>

            <pre><code>public override void OnActionReceived(ActionBuffers actionBuffers) {
    int action = actionBuffers.DiscreteActions[0];
    ExecuteAction(action);

    if (StepCount &gt;= MaxStep) {
        EndEpisode();
    }
}

public override void CollectObservations(VectorSensor sensor) {
    sensor.AddObservation(m_Position);
    sensor.AddObservation(m_Face);
    sensor.AddObservation(m_IsFull);

    for (int i = -m_ObservationRange; i &lt;= m_ObservationRange; i++) {
        for (int j = -m_ObservationRange; j &lt;= m_ObservationRange; j++) {
            int x = (int)m_Position.x + i;
            int z = (int)m_Position.z + j;
            if (x &gt;= 0 && x &lt; m_WorldData.Width && z &gt;= 0 && z &lt; m_WorldData.Height) {
                sensor.AddObservation(m_WorldData.Map[z, x].IsBlock);
                sensor.AddObservation(m_WorldData.Map[z, x].IsAgent);
            }
        }
    }
}</code></pre>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- VR & CAMERA -->
    <section id="vr" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Camera, Visualization, and VR Parity</h2>

            <p>
              The camera system auto-frames the environment based on map dimensions and supports smooth transitions via coroutines. Controls support both
              desktop inspection (pan/zoom/rotate) and VR interaction, maintaining feature parity across platforms using XR Interaction Toolkit and
              world-space UI prefabs.
            </p>

            <h3>Smooth camera transition</h3>
            <pre><code>private IEnumerator SmoothCameraTransition(Vector3 targetCenter, float targetDistance) {
    Vector3 startPosition = cameraTransform.position;
    Quaternion startRotation = cameraTransform.rotation;

    Vector3 endPosition = new Vector3(targetCenter.x, targetDistance, targetCenter.z - targetDistance / 2);
    Quaternion endRotation = Quaternion.LookRotation(targetCenter - endPosition);

    float duration = 1.5f;
    float elapsedTime = 0f;

    while (elapsedTime &lt; duration) {
        elapsedTime += Time.deltaTime;
        float t = elapsedTime / duration;

        cameraTransform.position = Vector3.Lerp(startPosition, endPosition, t);
        cameraTransform.rotation = Quaternion.Lerp(startRotation, endRotation, t);
        yield return null;
    }

    cameraTransform.position = endPosition;
    cameraTransform.rotation = endRotation;
}</code></pre>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- VOICE -->
    <section id="voice" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Voice Control via OpenAI Whisper API</h2>

            <p>
              Voice input improves accessibility and enables hands-free control. The workflow captures microphone audio, trims silence, sends a WAV file
              to the Whisper transcription endpoint, then parses the returned text into simulation commands (start/stop/move agent, etc.).
            </p>

            <h3>Sending audio to Whisper</h3>
            <pre><code>private async void SendAudioToWhisper(string filePath) {
    try {
        HttpClient client = new HttpClient();
        MultipartFormDataContent form = new MultipartFormDataContent();

        form.Add(new ByteArrayContent(File.ReadAllBytes(filePath)), "file", Path.GetFileName(filePath));

        HttpResponseMessage response =
            await client.PostAsync("https://api.openai.com/v1/audio/transcriptions", form);

        string result = await response.Content.ReadAsStringAsync();

        if (response.IsSuccessStatusCode) {
            ProcessCommand(result);
        } else {
            Debug.LogError($"Whisper API Error: {response.StatusCode}");
        }
    } catch (Exception ex) {
        Debug.LogError($"Error sending audio to Whisper API: {ex.Message}");
    }
}</code></pre>

            <h3>Command parsing</h3>
            <pre><code>private void ProcessCommand(string transcription) {
    if (transcription.Contains("start simulation", StringComparison.OrdinalIgnoreCase)) {
        simulationManager.StartSimulation();
    } else if (transcription.Contains("stop simulation", StringComparison.OrdinalIgnoreCase)) {
        simulationManager.StopSimulation();
    } else if (transcription.Contains("move agent", StringComparison.OrdinalIgnoreCase)) {
        Debug.Log($"Processing move command: {transcription}");
    } else {
        Debug.Log($"Unrecognized command: {transcription}");
    }
}</code></pre>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- DEBUG -->
    <section id="debug" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Real-Time Debugging</h2>

            <p>
              A debugging suite accelerates development and validation: on-scene overlays for paths and goals, centralized logging for agent actions and
              completions, and in-editor controls for pause/resume/reset. Gizmos provide immediate spatial diagnostics without polluting runtime visuals.
            </p>

            <pre><code>private void OnDrawGizmos() {
    if (!Application.isPlaying) return;

    foreach (var agent in agents) {
        Gizmos.color = Color.green;
        Gizmos.DrawLine(agent.transform.position, agent.TargetPosition);
    }

    foreach (var goal in goals) {
        Gizmos.color = Color.blue;
        Gizmos.DrawSphere(goal.Position, 0.5f);
    }
}</code></pre>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- CONCLUSION -->
    <section id="conclusion" class="post-section">
      <div class="post-container">
        <div class="blog-post-wrap">
          <article class="blog-post-card fade-in-slide">
            <h2 class="post-section-title">Conclusion and Future Work</h2>

            <p>
              Migrating from the legacy prototype to a modernized architecture substantially improved SAIME’s performance, scalability, and usability.
              ECS + pooling reduced runtime overhead and enabled larger environments; JSON-driven initialization unlocked rapid environment iteration; RL
              via ML-Agents enabled adaptive agent behaviors; and the addition of VR + voice control expanded interaction beyond traditional desktop inputs.
              The new architecture provides a stable foundation for research-grade simulation and further intelligent system development.
            </p>

            <h3>Future work</h3>
            <ul>
              <li><strong>Multi-agent collaboration:</strong> coordination policies, conflict resolution, cooperative task planning.</li>
              <li><strong>Enhanced training:</strong> curriculum learning, reward shaping, domain randomization.</li>
              <li><strong>Analytics overlays:</strong> heatmaps, throughput metrics, path efficiency dashboards.</li>
              <li><strong>Real-world bridges:</strong> robotics frameworks / WMS integration for sim-to-real workflows.</li>
              <li><strong>Richer JSON schema:</strong> rotation/scale, hierarchy, environment conditions, agent profiles.</li>
              <li><strong>Interaction expansion:</strong> gestures and AR for hybrid control.</li>
            </ul>

            <div class="post-nav">
              <a class="view-all-btn" href="#top">Back to top</a>
              <a class="view-all-btn" href="blog.html">Back to blog</a>
            </div>
          </article>
        </div>
      </div>
    </section>

  </main>

  <!-- =========================================================
       FOOTER (TEMPLATE-MATCH)
       ========================================================= -->
  <footer>
    <div class="container">
      <p>&copy; 2024 Joshua Davies. All rights reserved.</p>
      <ul class="social-media-links">
        <li>
          <a href="https://www.linkedin.com/in/joshuajdavies/" target="_blank" class="linkedin" rel="noopener">
            <i class="fab fa-linkedin"></i>
          </a>
        </li>
        <li>
          <a href="https://github.com/MilesJMaiden" target="_blank" class="github" rel="noopener">
            <i class="fab fa-github"></i>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/MilesJMaiden" target="_blank" class="twitter" rel="noopener">
            <i class="fab fa-twitter"></i>
          </a>
        </li>
        <li>
          <a href="#" target="_blank" class="instagram" rel="noopener">
            <i class="fab fa-instagram"></i>
          </a>
        </li>
        <li>
          <a href="#" target="_blank" class="facebook" rel="noopener">
            <i class="fab fa-facebook"></i>
          </a>
        </li>
      </ul>
    </div>
  </footer>

  <script defer src="js/blogpost.js"></script>
</body>
</html>
